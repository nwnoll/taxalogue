notes


NcbiTaxonomy
helpful: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3245000/

Other name types (includes and in-part) are for names which are useful as retrieval terms but which do not correspond with unique taxa in our classification (e.g. Reptilia).



single entry... use find_by
NcbiRankedLineage
gives all imprtant ranks
oen thing is that if the rank is non-standard than the name might not be present in the other ranks
another thing is that name gives the actual nam and ven if this taxon name is of rank species, on species, there is just an empty string

single entry use find_by
NcbiNode.where(tax_id: 1417371)
mainly useful for rank and parent_tax_id

multiple entires for tax_id use where
NcbiName.where(tax_id: 1417371)
gives info about taxonomic status..
all synonyms

possible name_classes
["synonym", "scientific name", "blast name", "genbank common name", "in-part", "authority", "equivalent name", "includes", "common name", "genbank synonym", "acronym", "genbank acronym"]
intersting here is:
    synonym -> this name is according to NCBI Taxonomy a synonym in the Webbrowser there is also the info if it homotypic or hetero dont know wehre it might be in the db
    scientific name -> binary .. trinomen.. without author
    authority -> binary + author




no synonyms allowed
NcbiName.where(name: "")
NcbiNode.find_by_tax_id(tax_id)
NcbiRankeLineage.find_by_tax_id(tax_id)

synonyms allowed
NcbiName.where(name: "") for tax_id and name_class
NcbiNode.find_by_tax_id(tax_id) for rank
NcbiRankeLineage.find_by_tax_id(tax_id) for rank names


pp NcbiName.where(name: "Reptilia")
[#<NcbiName:0x000055dbebfbcbc0
  id: 23181,
  tax_id: 8459,
  name: "Reptilia",
  unique_name: "Reptilia <turtles>",
  name_class: "in-part",
  created_at: 2021-02-02 20:51:39.250609 UTC,
  updated_at: 2021-02-02 20:51:39.250609 UTC>,
 #<NcbiName:0x000055dbebfe58b8
  id: 23309,
  tax_id: 8504,
  name: "Reptilia",
  unique_name: "Reptilia <lizards>",
  name_class: "in-part",
  created_at: 2021-02-02 20:51:39.250609 UTC,
  updated_at: 2021-02-02 20:51:39.250609 UTC>,
 #<NcbiName:0x000055dbebfe5728
  id: 1586854,
  tax_id: 1294634,
  name: "Reptilia",
  unique_name: "Reptilia <vertebrates>",
  name_class: "in-part",
  created_at: 2021-02-02 20:53:12.460127 UTC,
  updated_at: 2021-02-02 20:53:12.460127 UTC>]
#<ActiveRecord::Relation [#<NcbiName id: 23181, tax_id: 8459, name: "Reptilia", unique_name: "Reptilia <turtles>", name_class: "in-part", created_at: "2021-02-02 20:51:39", updated_at: "2021-02-02 20:51:39">, #<NcbiName id: 23309, tax_id: 8504, name: "Reptilia", unique_name: "Reptilia <lizards>", name_class: "in-part", created_at: "2021-02-02 20:51:39", updated_at: "2021-02-02 20:51:39">, #<NcbiName id: 1586854, tax_id: 1294634, name: "Reptilia", unique_name: "Reptilia <vertebrates>", name_class: "in-part", created_at: "2021-02-02 20:53:12", updated_at: "2021-02-02 20:53:12">]>
(byebug) pp NcbiName.where(name: "Satyridae")
[#<NcbiName:0x000055dbec10ac70
  id: 46154,
  tax_id: 33415,
  name: "Satyridae",
  unique_name: "",
  name_class: "includes",
  created_at: 2021-02-02 20:51:39.250609 UTC,
  updated_at: 2021-02-02 20:51:39.250609 UTC>]
#<ActiveRecord::Relation [#<NcbiName id: 46154, tax_id: 33415, name: "Satyridae", unique_name: "", name_class: "includes", created_at: "2021-02-02 20:51:39", updated_at: "2021-02-02 20:51:39">]>
(byebug) NcbiRankedLineage.where(tax_id: 33415)
#<ActiveRecord::Relation [#<NcbiRankedLineage id: 1043705, tax_id: 33415, name: "Nymphalidae", species: "", genus: "", familia: "", ordo: "Lepidoptera", classis: "Insecta", phylum: "Arthropoda", regnum: "Metazoa", super_regnum: "Eukaryota", created_at: "2021-02-02 20:56:45", updated_at: "2021-02-02 20:56:45">]>
(byebug) pp NcbiRankedLineage.where(tax_id: 33415)
[#<NcbiRankedLineage:0x000055dbec8bbc80
  id: 1043705,
  tax_id: 33415,
  name: "Nymphalidae",
  species: "",
  genus: "",
  familia: "",
  ordo: "Lepidoptera",
  classis: "Insecta",
  phylum: "Arthropoda",
  regnum: "Metazoa",
  super_regnum: "Eukaryota",
  created_at: 2021-02-02 20:56:45.339576 UTC,
  updated_at: 2021-02-02 20:56:45.339576 UTC>]
#<ActiveRecord::Relation [#<NcbiRankedLineage id: 1043705, tax_id: 33415, name: "Nymphalidae", species: "", genus: "", familia: "", ordo: "Lepidoptera", classis: "Insecta", phylum: "Arthropoda", regnum: "Metazoa", super_regnum: "Eukaryota", created_at: "2021-02-02 20:56:45", updated_at: "2021-02-02 20:56:45">]>
(byebug) 




for includes I actually could use tax_id, although it is not a synonym
for in-part it is more difficult since it seems that here are multiple tax_id associated..
eg Sympata includes 3 families

(byebug) pp NcbiName.where(name: "Sympata")
[#<NcbiName:0x00005604e1783bb0
  id: 44993,
  tax_id: 32409,
  name: "Sympata",
  unique_name: "Sympata <Pergidae>",
  name_class: "in-part",
  created_at: 2021-02-02 20:51:39.250609 UTC,
  updated_at: 2021-02-02 20:51:39.250609 UTC>,
 #<NcbiName:0x00005604e1783a20
  id: 52759,
  tax_id: 36760,
  name: "Sympata",
  unique_name: "Sympata <Xiphydriidae>",
  name_class: "in-part",
  created_at: 2021-02-02 20:51:39.250609 UTC,
  updated_at: 2021-02-02 20:51:39.250609 UTC>,
 #<NcbiName:0x00005604e1783840
  id: 75847,
  tax_id: 48206,
  name: "Sympata",
  unique_name: "Sympata <Xyelidae>",
  name_class: "in-part",
  created_at: 2021-02-02 20:51:39.250609 UTC,
  updated_at: 2021-02-02 20:51:39.250609 UTC>]


here the qestion could pop up if multiple taxa should be searched.. so these 3?
could look how i have done it in the BOLD downloader... just creating multiple configs?


no synonyms allowed

Search for NcbiName
if scientific_name  -> good -> take tax_id
if synonym          -> good -> take tax_id
if includes         -> good -> take tax_id
if in-part          -> unsure, could use all tax_ids and then download... but not really during taxonobject assignment..



with tax_id I will search the NcbiNode and use the rank information






type_name				-- name of type material type
	synonyms				-- alternative names for type material type
	nomenclature				-- Taxonomic Code of Nomenclature coded by a single letter:
						-- B - International Code for algae, fungi and plants (ICN), previously Botanical Code,
						-- P - International Code of Nomenclature of Prokaryotes (ICNP),
						-- Z - International Code of Zoological Nomenclature (ICZN),
						-- V - International Committee on Taxonomy of Viruses (ICTV) virus classification.
	description				-- descriptive text







taxon['rank'].blank? ? taxon_rank = 'unranked' : taxon_rank = taxon['rank'].downcase
taxon_rank.gsub!('sub', '') if taxon_rank =~ /sub/

taxonomic_status  = taxon['taxonomicStatus'].to_s.downcase
taxonomic_status  = 'accepted' if comment == :used_accepted_info
canonical_name    = _get_canonical_name(taxon)
combined          = _get_combined(taxon)
taxon['kingdom'] == 'Metazoa' ? kingdom = 'Animalia' : kingdom = taxon['kingdom']

OpenStruct.new(
    taxon_id:               taxon['nubKey'],
    api_taxon_id:           taxon['key'],
    regnum:                 kingdom,
    phylum:                 taxon['phylum'],
    classis:                taxon['class'],
    ordo:                   taxon['order'],
    familia:                taxon['family'],
    genus:                  taxon['genus'],
    canonical_name:         canonical_name,
    scientific_name:        taxon['scientificName'],
    taxonomic_status:       taxonomic_status,
    taxon_rank:             taxon_rank,
    combined:               combined,
    accepted_name_usage_id: nil,
    comment:                comment
)

probably I need to divide the Synoynm class into Ncbisynonym and GbifSynonym 
too much differences and it will make problems if i tr√Ω to combine both


migrate database
class RecreateNcbiNameTable < ActiveRecord::Migration[6.0]
    def change
        create_table :ncbi_names do |t|
            t.integer	:tax_id, index: true
            t.string 	:name, index: true
            t.string 	:unique_name
            t.string 	:name_class

            t.timestamps
        end
    end
end

RecreateNcbiNameTable.migrate(:down)
RecreateNcbiNameTable.migrate(:up)


# ### import ncbi names do not delete should use it for later....
# conf_params = Helper.json_file_to_hash('lib/configs/ncbi_taxonomy_config.json')
# config = Config.new(conf_params)
# file_manager = config.file_manager

# ncbi_name_importer = NcbiNameImporter.new(file_manager: file_manager, file_name: 'names.dmp')
# ncbi_name_importer.run
# ###



class RecreateNcbiRankedLineageTable < ActiveRecord::Migration[6.0]
    def change
        create_table :ncbi_ranked_lineages do |t|
            t.integer :tax_id, index: true
            t.string :name, index: true
            t.string :species
            t.string :genus
            t.string :familia
            t.string :ordo
            t.string :classis
            t.string :phylum
            t.string :regnum
            t.string :super_regnum

            t.timestamps
        end
    end
end

RecreateNcbiRankedLineageTable.migrate(:down)
RecreateNcbiRankedLineageTable.migrate(:up)



class RecreateNcbiRankedLineageTable < ActiveRecord::Migration[6.0]
    def change
        create_table :ncbi_ranked_lineages do |t|
            t.integer :tax_id, index: true
            t.string :name, index: true
            t.string :species
            t.string :genus
            t.string :familia
            t.string :ordo
            t.string :classis
            t.string :phylum
            t.string :regnum
            t.string :super_regnum

            t.timestamps
        end
    end
end

RecreateNcbiRankedLineageTable.migrate(:down)
RecreateNcbiRankedLineageTable.migrate(:up)


### import ncbi names do not delete should use it for later....
conf_params = Helper.json_file_to_hash('lib/configs/ncbi_taxonomy_config.json')
config = Config.new(conf_params)
file_manager = config.file_manager

ncbi_ranked_lineage_importer = NcbiRankedLineageImporter.new(file_manager: file_manager, file_name: 'rankedlineage.dmp')
ncbi_ranked_lineage_importer.run
###
exit



  def _taxon_object_proxy(taxon:, comment: nil)
    return if taxon.nil?
    
    taxon['rank'].blank? ? taxon_rank = 'unranked' : taxon_rank = taxon['rank'].downcase
    taxon_rank.gsub!('sub', '') if taxon_rank =~ /sub/
    
    taxonomic_status  = taxon['taxonomicStatus'].to_s.downcase
    taxonomic_status  = 'accepted' if comment == :used_accepted_info
    canonical_name    = _get_canonical_name(taxon)
    combined          = _get_combined(taxon)
    taxon['kingdom'] == 'Metazoa' ? kingdom = 'Animalia' : kingdom = taxon['kingdom']
    
    OpenStruct.new(
      taxon_id:               taxon['nubKey'],
      api_taxon_id:           taxon['key'],
      regnum:                 kingdom,
      phylum:                 taxon['phylum'],
      classis:                taxon['class'],
      ordo:                   taxon['order'],
      familia:                taxon['family'],
      genus:                  taxon['genus'],
      canonical_name:         canonical_name,
      scientific_name:        taxon['scientificName'],
      taxonomic_status:       taxonomic_status,
      taxon_rank:             taxon_rank,
      combined:               combined,
      accepted_name_usage_id: nil,
      comment:                comment
    )
  end

  def _get_canonical_name(taxon)
    canonical_name = ''
    possible_ranks = GbifTaxonomy.possible_ranks
    if are_synonyms_allowed
      if taxon['canonicalName'].blank?
        possible_ranks.reverse.each { |rank| canonical_name = taxon[rank] unless taxon[rank].blank? }
      else
        canonical_name = taxon['canonicalName'] unless taxon['canonicalName'].blank?
      end
    else
      possible_ranks.reverse.each { |rank| canonical_name = taxon[rank] unless taxon[rank].blank? }
    end

    return canonical_name
  end

  def _get_combined(taxon)
    combined = []
    possible_ranks = GbifTaxonomy.possible_ranks
    possible_ranks.reverse.each { |rank| combined.push(taxon[rank]) unless taxon[rank].blank? }
    
    return combined
  end
end

["no rank",
 "superkingdom",
 "genus",
 "species",
 "order",
 "family",
 "subspecies",
 "subfamily",
 "strain",
 "serogroup",
 "biotype",
 "tribe",
 "phylum",
 "class",
 "species group",
 "forma",
 "clade",
 "suborder",
 "subclass",
 "varietas",
 "kingdom",
 "subphylum",
 "forma specialis",
 "isolate",
 "infraorder",
 "superfamily",
 "infraclass",
 "superorder",
 "subgenus",
 "superclass",
 "parvorder",
 "serotype",
 "species subgroup",
 "subcohort",
 "cohort",
 "genotype",
 "subtribe",
 "section",
 "series",
 "subvariety",
 "morph",
 "subkingdom",
 "superphylum",
 "subsection",
 "pathogroup"]


How to gu with the unmapped option?
SHould it jast be the raw sequences information?
Problem here is that for GBOL we dont have ranks and although this would still for work the fasta output
a reliable way of constructing a TSV is impossible

another wy would be the distinction between raw -> really raw and unmapped... 
which means not mapped to a particular taxonomy but using all infromation possible to infer ranks..